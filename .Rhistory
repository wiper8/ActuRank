scores
joint_density
apply(scores, 1, function(score) {
#print(score)
if(is.na(score["joueur_A1"])) return(likelihood_1vs1_exact(joint_density, score))
likelihood_2vs2_exact(joint_density, score)
})
scores
scores
nrow(scores)
joint_density
nrow(joint_density$joint_distr)
update_scores_exact <- function(joint_density, scores) {
posteriori <- apply(
matrix(
apply(scores, 1, function(score) {
#print(score)
if(is.na(score["joueur_A1"])) return(likelihood_1vs1_exact(joint_density, score))
likelihood_2vs2_exact(joint_density, score)
}), nrow = nrow(joint_density$joint_distr), ncol = nrow(scores)
),
1, prod
) * joint_density$joint_distr$p
posteriori <- posteriori / sum(posteriori)
#players[pair] <- mapply(simplifier_domain, players[pair], step = ifelse(sapply(players[pair], function(distr) max(distr[, "mu"]) - min(distr[, "mu"])) > 50, 2, 1), SIMPLIFY = FALSE)
#if(max(sapply(players[pair], function(distr) sum(distr[, "p"]))) > 1.0001) stop("Erreur de prob A")
joint_density$joint_distr$p <- posteriori
joint_density
}
include_exact_points <- FALSE
dim_len_mu <- 5
source("src/import.R")
source("src/update_scores.R")
source("src/plots.R")
source("src/recommend.R")
# retirer Louis
scores <- scores[apply(
scores[, c("joueur_A1", "joueur_A2", "joueur_B1", "joueur_B2")],
1,
function(x) !("Louis" %in% x)
), ]
tmp <- show_ranking_history_dependancy(scores=scores)
include_exact_points <- FALSE
dim_len_mu <- 5
source("src/import.R")
source("src/update_scores.R")
source("src/plots.R")
source("src/recommend.R")
# retirer Louis
scores <- scores[apply(
scores[, c("joueur_A1", "joueur_A2", "joueur_B1", "joueur_B2")],
1,
function(x) !("Louis" %in% x)
), ]
name <- unique(unlist(scores[, c("joueur_A1", "joueur_A2", "joueur_B1", "joueur_B2")]))
name <- name[!is.na(name)]
clusters <- list()
game_dates <- as.Date(unique(scores[, "date"]))
game_dates <- sort(game_dates)
drift_dates <- as.character(seq.Date(as.Date(format(as.Date(min(scores[, "date"])), "%Y-%m-01")), as.Date(max(scores[, "date"])), by = "+1 month")[-1])
all_dates <- c(game_dates, as.Date(drift_dates))
all_dates <- unique(all_dates)
all_dates <- as.Date(all_dates)
all_dates <- sort(all_dates)
graph_data <- data.frame(
date = rep(all_dates, each = length(name)),
player = rep(name, length(all_dates)),
score = NA,
played = FALSE
)
ranks <- NULL
marginales <- list()
as.character(all_dates)
include_exact_points <- FALSE
dim_len_mu <- 5
source("src/import.R")
source("src/update_scores.R")
source("src/plots.R")
source("src/recommend.R")
# retirer Louis
scores <- scores[apply(
scores[, c("joueur_A1", "joueur_A2", "joueur_B1", "joueur_B2")],
1,
function(x) !("Louis" %in% x)
), ]
name <- unique(unlist(scores[, c("joueur_A1", "joueur_A2", "joueur_B1", "joueur_B2")]))
name <- name[!is.na(name)]
clusters <- list()
game_dates <- as.Date(unique(scores[, "date"]))
game_dates <- sort(game_dates)
drift_dates <- as.character(seq.Date(as.Date(format(as.Date(min(scores[, "date"])), "%Y-%m-01")), as.Date(max(scores[, "date"])), by = "+1 month")[-1])
all_dates <- c(game_dates, as.Date(drift_dates))
all_dates <- unique(all_dates)
all_dates <- as.Date(all_dates)
all_dates <- sort(all_dates)
graph_data <- data.frame(
date = rep(all_dates, each = length(name)),
player = rep(name, length(all_dates)),
score = NA,
played = FALSE
)
ranks <- NULL
marginales <- list()
for(d in as.character(all_dates[1:44])) {
print(d)
if(d %in% as.character(drift_dates)) {
clusters <- lapply(clusters, drift_exact)
}
if(d %in% as.character(game_dates)) {
n_to_update <- nrow(scores[scores[, "date"] == d, ])
# commencer avec le simple
# énumérer les paires de simples jouées dans la journée
scores_subset <- scores[scores[, "date"] == d, ]
scores_subset <- scores_subset[is.na(scores_subset$joueur_A1), ]
if (nrow(scores_subset) > 0) {
pairs <- mapply(function(a, b) {
sort(c(a, b))
}, scores_subset$joueur_A2, scores_subset$joueur_B1, SIMPLIFY = FALSE)
unique_pairs <- unique(pairs)
unique_pairs_game_i <- lapply(
unique_pairs,
function(x) which(sapply(pairs, function(y) isTRUE(all.equal(y, x))))
)
# pour chq paire, update
for (p in seq_along(unique_pairs)) {
# ajouter les nouveaux joueurs de cette partie i
players_this_game <- unique(unlist(scores_subset[unique_pairs_game_i[[p]], c("joueur_A2", "joueur_B1"), drop = FALSE]))
for(n in players_this_game[!players_this_game %in% unlist(sapply(clusters, `[[`, "names"))]) {
print(paste0("Ajout de : ", n, collapse = ""))
clusters <- add_player_dependancy(n, clusters)
}
# créer la distribution conjointe nécessaire pour la paire
groups_to_join <- which(sapply(lapply(clusters, `[[`, "names"), function(noms) any(unique_pairs[[p]] %in% noms)))
joint_distr_from_clusters <- join_clusters(clusters, groups_to_join)
if (isFALSE(all.equal(sum(joint_distr_from_clusters$joint_distr$p), 1))) {
print(d)
stop("Erreur de probs")
}
# simplifier
joint_distr_from_clusters <- simplifier_joint_dependancy(
joint_distr_from_clusters, seuil = 0.001,
absolute_max_dim = 1000000,
verbose = TRUE
)
# update la distribution
joint_density <- update_scores_exact(
joint_distr_from_clusters,
scores=scores_subset[unique_pairs_game_i[[p]], , drop = FALSE]
)
# re-simplifier
joint_density <- simplifier_joint_dependancy(
joint_density, seuil = 0.001,
absolute_max_dim = 1000000,
verbose = TRUE
)
# reclusterer
new_clusters <- recluster_dependancy(joint_density)
clusters <- c(new_clusters, clusters[!seq_along(clusters) %in% groups_to_join])
print(paste0(length(clusters), " clusters, length ", paste0(sapply(clusters, function(x) length(x$names)), collapse = ", ")))
#print(sapply(clusters, `[`, "names"))
}
}
# continuer avec le double
scores_subset <- scores[scores[, "date"] == d, ]
scores_subset <- scores_subset[!is.na(scores_subset$joueur_A1), ]
if (nrow(scores_subset) > 0) {
pairs <- mapply(function(a1, a2, b1, b2) {
sort(c(a1, a2, b1, b2))
}, scores_subset$joueur_A1, scores_subset$joueur_A2,
scores_subset$joueur_B1, scores_subset$joueur_B2, SIMPLIFY = FALSE)
unique_pairs <- unique(pairs)
unique_pairs_game_i <- lapply(
unique_pairs,
function(x) which(sapply(pairs, function(y) isTRUE(all.equal(y, x))))
)
# pour chq paire, update
for (p in seq_along(unique_pairs)) {
# ajouter les nouveaux joueurs de cette partie i
players_this_game <- unique(unlist(scores_subset[unique_pairs_game_i[[p]], c("joueur_A1", "joueur_A2", "joueur_B1", "joueur_B2"), drop = FALSE]))
for(n in players_this_game[!players_this_game %in% unlist(sapply(clusters, `[[`, "names"))]) {
print(paste0("Ajout de : ", n, collapse = ""))
clusters <- add_player_dependancy(n, clusters)
}
# créer la distribution conjointe nécessaire pour la paire
groups_to_join <- which(sapply(lapply(clusters, `[[`, "names"), function(noms) any(unique_pairs[[p]] %in% noms)))
joint_distr_from_clusters <- join_clusters(clusters, groups_to_join)
# simplifier
joint_distr_from_clusters <- simplifier_joint_dependancy(
joint_distr_from_clusters, seuil = 0.001,
absolute_max_dim = 1000000,
verbose = TRUE
)
# update la distribution
joint_density <- update_scores_exact(
joint_distr_from_clusters,
scores=scores_subset[unique_pairs_game_i[[p]], , drop = FALSE]
)
# re-simplifier
joint_density <- simplifier_joint_dependancy(
joint_density, seuil = 0.001,
absolute_max_dim = 1000000,
verbose = TRUE
)
# reclusterer
new_clusters <- recluster_dependancy(joint_density)
clusters <- c(new_clusters, clusters[!seq_along(clusters) %in% groups_to_join])
print(paste0(length(clusters), " clusters, length ", paste0(sapply(clusters, function(x) length(x$names)), collapse = ", ")))
#print(sapply(clusters, `[`, "names"))
}
}
}
marginales <- marginal_from_joint_dependancy(clusters)
ranks <- show_current_ranking(players = marginales, scores = scores, init_theta = ranks)
for(n in names(marginales)) graph_data[graph_data[, "date"] == d & graph_data[, "player"] == n, "score"] <- ranks[n]
players_today <- unique(unlist(scores[scores[, "date"] == d, c("joueur_A1", "joueur_A2", "joueur_B1", "joueur_B2")]))
players_today <- players_today[!is.na(players_today)]
for(n in players_today) graph_data[graph_data[, "date"] == d & graph_data[, "player"] == n, "played"] <- TRUE
#print(show_detailed_skill_per_player(marginales))
}
d=as.character(all_dates[45])
if(d %in% as.character(drift_dates)) {
clusters <- lapply(clusters, drift_exact)
}
d %in% as.character(game_dates)
n_to_update <- nrow(scores[scores[, "date"] == d, ])
n_to_update
# commencer avec le simple
# énumérer les paires de simples jouées dans la journée
scores_subset <- scores[scores[, "date"] == d, ]
scores_subset <- scores_subset[is.na(scores_subset$joueur_A1), ]
scores_subset
pairs <- mapply(function(a, b) {
sort(c(a, b))
}, scores_subset$joueur_A2, scores_subset$joueur_B1, SIMPLIFY = FALSE)
unique_pairs <- unique(pairs)
unique_pairs_game_i <- lapply(
unique_pairs,
function(x) which(sapply(pairs, function(y) isTRUE(all.equal(y, x))))
)
seq_along(unique_pairs)
p=1
# ajouter les nouveaux joueurs de cette partie i
players_this_game <- unique(unlist(scores_subset[unique_pairs_game_i[[p]], c("joueur_A2", "joueur_B1"), drop = FALSE]))
for(n in players_this_game[!players_this_game %in% unlist(sapply(clusters, `[[`, "names"))]) {
print(paste0("Ajout de : ", n, collapse = ""))
clusters <- add_player_dependancy(n, clusters)
}
# créer la distribution conjointe nécessaire pour la paire
groups_to_join <- which(sapply(lapply(clusters, `[[`, "names"), function(noms) any(unique_pairs[[p]] %in% noms)))
joint_distr_from_clusters <- join_clusters(clusters, groups_to_join)
if (isFALSE(all.equal(sum(joint_distr_from_clusters$joint_distr$p), 1))) {
print(d)
stop("Erreur de probs")
}
# simplifier
joint_distr_from_clusters <- simplifier_joint_dependancy(
joint_distr_from_clusters, seuil = 0.001,
absolute_max_dim = 1000000,
verbose = TRUE
)
# update la distribution
joint_density <- update_scores_exact(
joint_distr_from_clusters,
scores=scores_subset[unique_pairs_game_i[[p]], , drop = FALSE]
)
# re-simplifier
joint_density <- simplifier_joint_dependancy(
joint_density, seuil = 0.001,
absolute_max_dim = 1000000,
verbose = TRUE
)
# reclusterer
new_clusters <- recluster_dependancy(joint_density)
clusters <- c(new_clusters, clusters[!seq_along(clusters) %in% groups_to_join])
print(paste0(length(clusters), " clusters, length ", paste0(sapply(clusters, function(x) length(x$names)), collapse = ", ")))
seq_along(unique_pairs)
# pour chq paire, update
for (p in 2:6) {
# ajouter les nouveaux joueurs de cette partie i
players_this_game <- unique(unlist(scores_subset[unique_pairs_game_i[[p]], c("joueur_A2", "joueur_B1"), drop = FALSE]))
for(n in players_this_game[!players_this_game %in% unlist(sapply(clusters, `[[`, "names"))]) {
print(paste0("Ajout de : ", n, collapse = ""))
clusters <- add_player_dependancy(n, clusters)
}
# créer la distribution conjointe nécessaire pour la paire
groups_to_join <- which(sapply(lapply(clusters, `[[`, "names"), function(noms) any(unique_pairs[[p]] %in% noms)))
joint_distr_from_clusters <- join_clusters(clusters, groups_to_join)
if (isFALSE(all.equal(sum(joint_distr_from_clusters$joint_distr$p), 1))) {
print(d)
stop("Erreur de probs")
}
# simplifier
joint_distr_from_clusters <- simplifier_joint_dependancy(
joint_distr_from_clusters, seuil = 0.001,
absolute_max_dim = 1000000,
verbose = TRUE
)
# update la distribution
joint_density <- update_scores_exact(
joint_distr_from_clusters,
scores=scores_subset[unique_pairs_game_i[[p]], , drop = FALSE]
)
# re-simplifier
joint_density <- simplifier_joint_dependancy(
joint_density, seuil = 0.001,
absolute_max_dim = 1000000,
verbose = TRUE
)
# reclusterer
new_clusters <- recluster_dependancy(joint_density)
clusters <- c(new_clusters, clusters[!seq_along(clusters) %in% groups_to_join])
print(paste0(length(clusters), " clusters, length ", paste0(sapply(clusters, function(x) length(x$names)), collapse = ", ")))
#print(sapply(clusters, `[`, "names"))
}
# continuer avec le double
scores_subset <- scores[scores[, "date"] == d, ]
scores_subset <- scores_subset[!is.na(scores_subset$joueur_A1), ]
scores_subset
if (nrow(scores_subset) > 0) {
pairs <- mapply(function(a1, a2, b1, b2) {
sort(c(a1, a2, b1, b2))
}, scores_subset$joueur_A1, scores_subset$joueur_A2,
scores_subset$joueur_B1, scores_subset$joueur_B2, SIMPLIFY = FALSE)
unique_pairs <- unique(pairs)
unique_pairs_game_i <- lapply(
unique_pairs,
function(x) which(sapply(pairs, function(y) isTRUE(all.equal(y, x))))
)
# pour chq paire, update
for (p in seq_along(unique_pairs)) {
# ajouter les nouveaux joueurs de cette partie i
players_this_game <- unique(unlist(scores_subset[unique_pairs_game_i[[p]], c("joueur_A1", "joueur_A2", "joueur_B1", "joueur_B2"), drop = FALSE]))
for(n in players_this_game[!players_this_game %in% unlist(sapply(clusters, `[[`, "names"))]) {
print(paste0("Ajout de : ", n, collapse = ""))
clusters <- add_player_dependancy(n, clusters)
}
# créer la distribution conjointe nécessaire pour la paire
groups_to_join <- which(sapply(lapply(clusters, `[[`, "names"), function(noms) any(unique_pairs[[p]] %in% noms)))
joint_distr_from_clusters <- join_clusters(clusters, groups_to_join)
# simplifier
joint_distr_from_clusters <- simplifier_joint_dependancy(
joint_distr_from_clusters, seuil = 0.001,
absolute_max_dim = 1000000,
verbose = TRUE
)
# update la distribution
joint_density <- update_scores_exact(
joint_distr_from_clusters,
scores=scores_subset[unique_pairs_game_i[[p]], , drop = FALSE]
)
# re-simplifier
joint_density <- simplifier_joint_dependancy(
joint_density, seuil = 0.001,
absolute_max_dim = 1000000,
verbose = TRUE
)
# reclusterer
new_clusters <- recluster_dependancy(joint_density)
clusters <- c(new_clusters, clusters[!seq_along(clusters) %in% groups_to_join])
print(paste0(length(clusters), " clusters, length ", paste0(sapply(clusters, function(x) length(x$names)), collapse = ", ")))
#print(sapply(clusters, `[`, "names"))
}
}
marginales <- marginal_from_joint_dependancy(clusters)
marginales
ranks <- show_current_ranking(players = marginales, scores = scores, init_theta = ranks)
for(n in names(marginales)) graph_data[graph_data[, "date"] == d & graph_data[, "player"] == n, "score"] <- ranks[n]
players_today <- unique(unlist(scores[scores[, "date"] == d, c("joueur_A1", "joueur_A2", "joueur_B1", "joueur_B2")]))
players_today <- players_today[!is.na(players_today)]
for(n in players_today) graph_data[graph_data[, "date"] == d & graph_data[, "player"] == n, "played"] <- TRUE
print(d)
d=as.character(all_dates[46])
d
all_dates
print(d)
if(d %in% as.character(drift_dates)) {
clusters <- lapply(clusters, drift_exact)
}
d %in% as.character(game_dates)
n_to_update <- nrow(scores[scores[, "date"] == d, ])
# commencer avec le simple
# énumérer les paires de simples jouées dans la journée
scores_subset <- scores[scores[, "date"] == d, ]
scores_subset <- scores_subset[is.na(scores_subset$joueur_A1), ]
if (nrow(scores_subset) > 0) {
pairs <- mapply(function(a, b) {
sort(c(a, b))
}, scores_subset$joueur_A2, scores_subset$joueur_B1, SIMPLIFY = FALSE)
unique_pairs <- unique(pairs)
unique_pairs_game_i <- lapply(
unique_pairs,
function(x) which(sapply(pairs, function(y) isTRUE(all.equal(y, x))))
)
# pour chq paire, update
for (p in seq_along(unique_pairs)) {
# ajouter les nouveaux joueurs de cette partie i
players_this_game <- unique(unlist(scores_subset[unique_pairs_game_i[[p]], c("joueur_A2", "joueur_B1"), drop = FALSE]))
for(n in players_this_game[!players_this_game %in% unlist(sapply(clusters, `[[`, "names"))]) {
print(paste0("Ajout de : ", n, collapse = ""))
clusters <- add_player_dependancy(n, clusters)
}
# créer la distribution conjointe nécessaire pour la paire
groups_to_join <- which(sapply(lapply(clusters, `[[`, "names"), function(noms) any(unique_pairs[[p]] %in% noms)))
joint_distr_from_clusters <- join_clusters(clusters, groups_to_join)
if (isFALSE(all.equal(sum(joint_distr_from_clusters$joint_distr$p), 1))) {
print(d)
stop("Erreur de probs")
}
# simplifier
joint_distr_from_clusters <- simplifier_joint_dependancy(
joint_distr_from_clusters, seuil = 0.001,
absolute_max_dim = 1000000,
verbose = TRUE
)
# update la distribution
joint_density <- update_scores_exact(
joint_distr_from_clusters,
scores=scores_subset[unique_pairs_game_i[[p]], , drop = FALSE]
)
# re-simplifier
joint_density <- simplifier_joint_dependancy(
joint_density, seuil = 0.001,
absolute_max_dim = 1000000,
verbose = TRUE
)
# reclusterer
new_clusters <- recluster_dependancy(joint_density)
clusters <- c(new_clusters, clusters[!seq_along(clusters) %in% groups_to_join])
print(paste0(length(clusters), " clusters, length ", paste0(sapply(clusters, function(x) length(x$names)), collapse = ", ")))
#print(sapply(clusters, `[`, "names"))
}
}
# continuer avec le double
scores_subset <- scores[scores[, "date"] == d, ]
scores_subset <- scores_subset[!is.na(scores_subset$joueur_A1), ]
if (nrow(scores_subset) > 0) {
pairs <- mapply(function(a1, a2, b1, b2) {
sort(c(a1, a2, b1, b2))
}, scores_subset$joueur_A1, scores_subset$joueur_A2,
scores_subset$joueur_B1, scores_subset$joueur_B2, SIMPLIFY = FALSE)
unique_pairs <- unique(pairs)
unique_pairs_game_i <- lapply(
unique_pairs,
function(x) which(sapply(pairs, function(y) isTRUE(all.equal(y, x))))
)
# pour chq paire, update
for (p in seq_along(unique_pairs)) {
# ajouter les nouveaux joueurs de cette partie i
players_this_game <- unique(unlist(scores_subset[unique_pairs_game_i[[p]], c("joueur_A1", "joueur_A2", "joueur_B1", "joueur_B2"), drop = FALSE]))
for(n in players_this_game[!players_this_game %in% unlist(sapply(clusters, `[[`, "names"))]) {
print(paste0("Ajout de : ", n, collapse = ""))
clusters <- add_player_dependancy(n, clusters)
}
# créer la distribution conjointe nécessaire pour la paire
groups_to_join <- which(sapply(lapply(clusters, `[[`, "names"), function(noms) any(unique_pairs[[p]] %in% noms)))
joint_distr_from_clusters <- join_clusters(clusters, groups_to_join)
# simplifier
joint_distr_from_clusters <- simplifier_joint_dependancy(
joint_distr_from_clusters, seuil = 0.001,
absolute_max_dim = 1000000,
verbose = TRUE
)
# update la distribution
joint_density <- update_scores_exact(
joint_distr_from_clusters,
scores=scores_subset[unique_pairs_game_i[[p]], , drop = FALSE]
)
# re-simplifier
joint_density <- simplifier_joint_dependancy(
joint_density, seuil = 0.001,
absolute_max_dim = 1000000,
verbose = TRUE
)
# reclusterer
new_clusters <- recluster_dependancy(joint_density)
clusters <- c(new_clusters, clusters[!seq_along(clusters) %in% groups_to_join])
print(paste0(length(clusters), " clusters, length ", paste0(sapply(clusters, function(x) length(x$names)), collapse = ", ")))
#print(sapply(clusters, `[`, "names"))
}
}
marginales <- marginal_from_joint_dependancy(clusters)
ranks <- show_current_ranking(players = marginales, scores = scores, init_theta = ranks)
for(n in names(marginales)) graph_data[graph_data[, "date"] == d & graph_data[, "player"] == n, "score"] <- ranks[n]
players_today <- unique(unlist(scores[scores[, "date"] == d, c("joueur_A1", "joueur_A2", "joueur_B1", "joueur_B2")]))
players_today <- players_today[!is.na(players_today)]
for(n in players_today) graph_data[graph_data[, "date"] == d & graph_data[, "player"] == n, "played"] <- TRUE
include_exact_points <- FALSE
dim_len_mu <- 5
source("src/import.R")
source("src/update_scores.R")
source("src/plots.R")
source("src/recommend.R")
# retirer Louis
scores <- scores[apply(
scores[, c("joueur_A1", "joueur_A2", "joueur_B1", "joueur_B2")],
1,
function(x) !("Louis" %in% x)
), ]
tmp <- show_ranking_history_dependancy(scores=scores)
include_exact_points <- FALSE
dim_len_mu <- 10
source("src/import.R")
source("src/update_scores.R")
source("src/plots.R")
source("src/recommend.R")
# retirer Louis
scores <- scores[apply(
scores[, c("joueur_A1", "joueur_A2", "joueur_B1", "joueur_B2")],
1,
function(x) !("Louis" %in% x)
), ]
tmp <- show_ranking_history_dependancy(scores=scores)
